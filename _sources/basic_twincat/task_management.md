# TwinCATのタスク管理

## SYSTEM-RealTime

## タスクを作成してPLCプログラムを実行する

## コンテキスト管理

ADSを使った他のコンポーネントとのデータ交換はタスクのコンテキストを通じて行われます。たとえば、ADSプロトコルのNotificationでは、クライアント側から都度問合せを行って変数の値を得るのではなく、あらかじめ登録しておいた変数についてサーバ側から任意のタイミングでデータを通知し続ける機構を提供します。データを通知するタイミング条件には[さまざまなモード](https://infosys.beckhoff.com/content/1033/tcadsnetref/7313078411.html?id=3697814533568076100)が用意されています。たとえば `SERVER On Change` という方式の場合、TwinCATのタスク周期毎にシンボルの値チェックを行って変化が有れば通知する、という仕様になっています。Scope viewやAnalytics loggerなどの時系列データ収集機構についてもこの仕組みを用いますので、タスクサイクルごとの値の変化をすべて収集することができます。

個々の変数がどのタスクによりこの処理が行われているか（このタスクをコンテキストと呼びます）については、TwinCATが自動的に決定する仕様となっています。必ずしも変数宣言したプログラムが所属するタスクとは限りません。たとえば、次図の例では、MAINプログラムが所属する`PlcTask`とは別に`SlowTask`が存在します。それぞれにプログラムがあり、それぞれに `AT%I*` で定義された入力変数があります。`PlcTask`は $250\mu s$ で、`SlowTask` は $10ms$ のサイクルタイムですが、MAINプログラムで宣言した `MAIN.inVar` 変数は残念ながら `SlowTask` のコンテキストに組み入れられています。つまり、ADSを介して他のアプリケーションから収集できる周期についても、 $10ms$ となります。

![](assets/2025-12-01-20-36-49.png){align=center}

では、個々のプログラムで宣言した変数はどのコンテキストで処理されているか、を確認するには、次のとおりTMCエディタのData Areasツリーを一覧します。

![](assets/2025-12-01-17-45-50.png){align=center}

このツリーでは、個々の変数シンボルが次のとおり、任意のコンテキスト（タスク）により通知されるかがわかるようになっています。

```{csv-table}
:header: ツリー名称, 対象シンボル
:widths: 4,6

<タスク名> Internal, 内部データ
<タスク名> Inputs, `AT%I*` 入力シンボル
<タスク名> Outputs, `AT%Q*` 出力シンボル
```

### 任意のコンテキストに所属させる

前節の説明のとおり、変数が処理されるコンテキストは自動割り当てとなります。この理由は、タスクが増えた場合それぞれのコンテキストでADSルータとの通信を行うと、それだけオーバヘッドが大きくなり、レイテンシにつながる恐れがあるためです。

しかし、タスクサイクル毎の変数の変化を観察したい場合、任意のタスクサイクルでコンテキスト処理を行うことが求められます。この場合、変数宣言部において `TcContextName` のattributeにて対象タスクを指定することで、そのタスクサイクル毎にNotificationの通知を受けることが可能になります。

[参考InfoSys](https://infosys.beckhoff.com/content/1033/tc3_plc_intro/3107930379.html?id=1421212854601188835)

この設定を行いビルドを実施すると、先ほどの例では、`MAIN.inVar` は `SlowTask` のタスクインスタンスとして一覧されていましたが、`PlcTask`タスクのInputインスタンスとして登録されます。

```{code-block} iecst
VAR
    {attribute 'TcContextName':='PlcTask'}
    inVar AT%I* : INT;
END_VAR
```

![](assets/2025-12-01-18-03-49.png){align=center}